"use strict";(self.webpackChunkdocs_reanimated=self.webpackChunkdocs_reanimated||[]).push([[5972],{15680:(e,n,t)=>{t.d(n,{xA:()=>d,yg:()=>h});var a=t(96540);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(t),m=r,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||i;return t?a.createElement(h,o(o({ref:n},d),{},{components:t})):a.createElement(h,o({ref:n},d))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},41007:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=t(58168),r=(t(96540),t(15680));const i={id:"useAnimatedReaction",title:"useAnimatedReaction",sidebar_label:"useAnimatedReaction"},o=void 0,s={unversionedId:"api/hooks/useAnimatedReaction",id:"version-2.x/api/hooks/useAnimatedReaction",title:"useAnimatedReaction",description:"useAnimatedReaction hook allows performing certain actions on some shared values' change. The key idea is, all of the shared values included in the first worklet are the inputs set. Every time any of those change both worklets are triggered in the order specified above. Also the second worklet may modify any shared values excluding those used in the first worklet.",source:"@site/versioned_docs/version-2.x/api/hooks/useAnimatedReaction.md",sourceDirName:"api/hooks",slug:"/api/hooks/useAnimatedReaction",permalink:"/react-native-reanimated/docs/2.x/api/hooks/useAnimatedReaction",draft:!1,editUrl:"https://github.com/software-mansion/react-native-reanimated/edit/main/packages/docs-reanimated/versioned_docs/version-2.x/api/hooks/useAnimatedReaction.md",tags:[],version:"2.x",frontMatter:{id:"useAnimatedReaction",title:"useAnimatedReaction",sidebar_label:"useAnimatedReaction"},sidebar:"docs",previous:{title:"useAnimatedProps",permalink:"/react-native-reanimated/docs/2.x/api/hooks/useAnimatedProps"},next:{title:"useAnimatedRef",permalink:"/react-native-reanimated/docs/2.x/api/hooks/useAnimatedRef"}},l={},c=[{value:"Arguments",id:"arguments",level:3},{value:"<code>prepare</code> Function",id:"prepare-function",level:4},{value:"<code>react</code> Function",id:"react-function",level:4},{value:"<code>dependencies</code> Array",id:"dependencies-array",level:4},{value:"Example",id:"example",level:2}],d={toc:c},u="wrapper";function p(e){let{components:n,...t}=e;return(0,r.yg)(u,(0,a.A)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"useAnimatedReaction")," hook allows performing certain actions on some shared values' change. The key idea is, all of the shared values included in the first worklet are the inputs set. Every time any of those change both worklets are triggered in the order specified above. Also the second worklet may modify any shared values excluding those used in the first worklet."),(0,r.yg)("h3",{id:"arguments"},"Arguments"),(0,r.yg)("h4",{id:"prepare-function"},(0,r.yg)("inlineCode",{parentName:"h4"},"prepare")," ","[Function]"),(0,r.yg)("p",null,"worklet used for data preparation for the second parameter. It also defines the inputs, in other words on which shared values change will it be called."),(0,r.yg)("h4",{id:"react-function"},(0,r.yg)("inlineCode",{parentName:"h4"},"react")," ","[Function]"),(0,r.yg)("p",null,"worklet which takes data prepared by the ",(0,r.yg)("inlineCode",{parentName:"p"},"prepare")," callback (being the first parameter of the hook) and performs some actions. As a second parameter it receives a result of the previous ",(0,r.yg)("inlineCode",{parentName:"p"},"prepare")," call(starting with ",(0,r.yg)("inlineCode",{parentName:"p"},"null"),"). It can modify any shared values but those which are mentioned in the first worklet. Beware of that, because this may result in endless loop and high cpu usage."),(0,r.yg)("h4",{id:"dependencies-array"},(0,r.yg)("inlineCode",{parentName:"h4"},"dependencies")," ","[Array]"),(0,r.yg)("p",null,"Optional array of values which changes cause this hook to receive updated values during rerender of the wrapping component. This matters when, for instance, worklet uses values dependent on the component's state."),(0,r.yg)("p",null,"Example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js",metastring:"{10}","{10}":!0},"const App = () => {\n  const [state, setState] = useState(0);\n  const sv1 = useSharedValue(0);\n  const sv2 = useSharedValue(0);\n\n  const derived = useAnimatedReaction(\n    () => {\n      return sv1.value * state;\n    },\n    (result, previous) => {\n      if (result !== previous) {\n        sv2.value = result - 5;\n      }\n    },\n    dependencies\n  );\n  //...\n  return <></>;\n};\n")),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"dependencies")," here may be:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"undefined"),"(argument skipped) - worklets will be rebuilt if there is any change in their bodies or any values from their closure(variables from outer scope used in worklet),"),(0,r.yg)("li",{parentName:"ul"},"empty array(",(0,r.yg)("inlineCode",{parentName:"li"},"[]"),") - worklets will be rebuilt only if their body change,"),(0,r.yg)("li",{parentName:"ul"},"array of values(",(0,r.yg)("inlineCode",{parentName:"li"},"[val1, val2, ..., valN]"),") - worklets will be rebuilt if there is any change in their bodies or any values from the given array.")),(0,r.yg)("h2",{id:"example"},"Example"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-js"},"const x = useSharedValue(0);\nconst x2 = useSharedValue(0);\n\nconst maxX2 = 80;\nuseAnimatedReaction(\n  () => {\n    return x.value / 1.5;\n  },\n  (data) => {\n    // data holds what was returned from the first worklet's execution\n    if (x2.value < maxX2) {\n      x2.value = data;\n    }\n  }\n);\n")))}p.isMDXComponent=!0}}]);