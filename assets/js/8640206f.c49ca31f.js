"use strict";(self.webpackChunkdocs_reanimated=self.webpackChunkdocs_reanimated||[]).push([[3551],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>f});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),s=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=s(e.components);return r.createElement(c.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=s(t),m=a,f=u["".concat(c,".").concat(m)]||u[m]||p[m]||o;return t?r.createElement(f,l(l({ref:n},d),{},{components:t})):r.createElement(f,l({ref:n},d))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,l=new Array(o);l[0]=m;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i[u]="string"==typeof e?e:a,l[1]=i;for(var s=2;s<o;s++)l[s]=t[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},39716:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>x,contentTitle:()=>S,default:()=>_,frontMatter:()=>b,metadata:()=>w,toc:()=>N});var r=t(87462),a=t(67294),o=t(3905),l=t(92747),i=t(67177),c=t(76636),s=t(28033),d=t(42233);const u=d.default.createAnimatedComponent(l.Z),p=()=>{const e=["#fa7f7c","#b58df1","#ffe780","#82cab2","#87cce8"].map(((e,n)=>a.createElement(i.Z,{key:n,style:[g.section,{backgroundColor:e}]})));return a.createElement(i.Z,{style:g.container},e)},m={code:"function AnimatedScrollHandlerTsx1(event){const{offsetX}=this.__closure;offsetX.value=event.contentOffset.y;}"},f={code:"function AnimatedScrollHandlerTsx2(e){console.log('The list is moving.');}"},h={code:"function AnimatedScrollHandlerTsx3(e){console.log('The list stopped moving.');}"},k={code:'function AnimatedScrollHandlerTsx4(){const{offsetX}=this.__closure;return{text:"Scroll offset: "+Math.round(offsetX.value)+"px",defaultValue:"Scroll offset: "+offsetX.value+"x"};}'};function v(){const e=(0,d.useSharedValue)(0),n=(0,d.useAnimatedScrollHandler)({onScroll:function(){const n=function(n){e.value=n.contentOffset.y};return n.__closure={offsetX:e},n.__workletHash=4249345862468,n.__initData=m,n}(),onMomentumBegin:function(){const e=function(e){console.log("The list is moving.")};return e.__closure={},e.__workletHash=0xf8de61d5c5c,e.__initData=f,e}(),onMomentumEnd:function(){const e=function(e){console.log("The list stopped moving.")};return e.__closure={},e.__workletHash=0xef2f36ee9ae,e.__initData=h,e}()}),t=(0,d.useAnimatedProps)(function(){const n=function(){return{text:`Scroll offset: ${Math.round(e.value)}px`,defaultValue:`Scroll offset: ${e.value}x`}};return n.__closure={offsetX:e},n.__workletHash=9021713955745,n.__initData=k,n}());return a.createElement(c.Z,{style:g.container},a.createElement(u,{animatedProps:t,editable:!1,style:g.header}),a.createElement(d.default.ScrollView,{onScroll:n},a.createElement(p,null)))}const g=s.Z.create({container:{paddingHorizontal:32,height:350},header:{backgroundColor:"#f8f9ff",paddingVertical:16,paddingHorizontal:16,textAlign:"center",fontFamily:"Aeonik",color:"#001a72",marginTop:"-1px"},section:{height:150,borderRadius:20,marginVertical:10,marginHorizontal:20}}),y="import React from 'react';\nimport { View, StyleSheet, TextInput, SafeAreaView } from 'react-native';\nimport Animated, {\n  useSharedValue,\n  useAnimatedProps,\n  useAnimatedScrollHandler,\n} from 'react-native-reanimated';\n\nconst AnimatedTextInput = Animated.createAnimatedComponent(TextInput);\n\nconst Content = () => {\n  const BRAND_COLORS = ['#fa7f7c', '#b58df1', '#ffe780', '#82cab2', '#87cce8'];\n\n  const content = BRAND_COLORS.map((color, index) => (\n    <View\n      key={index}\n      style={[\n        styles.section,\n        {\n          backgroundColor: color,\n        },\n      ]}\n    />\n  ));\n\n  return <View style={styles.container}>{content}</View>;\n};\n\nexport default function ScrollExample() {\n  const offsetX = useSharedValue(0);\n\n  const scrollHandler = useAnimatedScrollHandler({\n    onScroll: (event) => {\n      offsetX.value = event.contentOffset.y;\n    },\n    onMomentumBegin: (e) => {\n      console.log('The list is moving.');\n    },\n    onMomentumEnd: (e) => {\n      console.log('The list stopped moving.');\n    },\n  });\n\n  const offsetAnimatedProps = useAnimatedProps(() => {\n    return {\n      text: `Scroll offset: ${Math.round(offsetX.value)}px`,\n      defaultValue: `Scroll offset: ${offsetX.value}x`,\n    };\n  });\n\n  return (\n    <SafeAreaView style={styles.container}>\n      <AnimatedTextInput\n        animatedProps={offsetAnimatedProps}\n        editable={false}\n        style={styles.header}\n      />\n      <Animated.ScrollView onScroll={scrollHandler}>\n        <Content />\n      </Animated.ScrollView>\n    </SafeAreaView>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    paddingHorizontal: 32,\n    height: 350,\n  },\n  header: {\n    backgroundColor: '#f8f9ff',\n    paddingVertical: 16,\n    paddingHorizontal: 16,\n    textAlign: 'center',\n    fontFamily: 'Aeonik',\n    color: '#001a72',\n    marginTop: '-1px',\n  },\n  section: {\n    height: 150,\n    borderRadius: 20,\n    marginVertical: 10,\n    marginHorizontal: 20,\n  },\n});\n",b={sidebar_position:3},S="useAnimatedScrollHandler",w={unversionedId:"scroll/useAnimatedScrollHandler",id:"scroll/useAnimatedScrollHandler",title:"useAnimatedScrollHandler",description:"useAnimatedScrollHandler is a hook that returns an event handler reference. It can be used with React Native's scrollable components.",source:"@site/docs/scroll/useAnimatedScrollHandler.mdx",sourceDirName:"scroll",slug:"/scroll/useAnimatedScrollHandler",permalink:"/react-native-reanimated/docs/scroll/useAnimatedScrollHandler",draft:!1,editUrl:"https://github.com/software-mansion/react-native-reanimated/edit/main/packages/docs-reanimated/docs/scroll/useAnimatedScrollHandler.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"useScrollViewOffset",permalink:"/react-native-reanimated/docs/scroll/useScrollViewOffset"},next:{title:"Device",permalink:"/react-native-reanimated/docs/category/device"}},x={},N=[{value:"Reference",id:"reference",level:2},{value:"Arguments",id:"arguments",level:3},{value:"<code>handlers</code>",id:"handlers",level:4},{value:"<code>dependencies</code> <Optional />",id:"dependencies-",level:4},{value:"Returns",id:"returns",level:3},{value:"Example",id:"example",level:2},{value:"Remarks",id:"remarks",level:2},{value:"Platform compatibility",id:"platform-compatibility",level:2}],A=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",n)},C=A("Optional"),H=A("InteractiveExample"),O={toc:N},T="wrapper";function _(e){let{components:n,...t}=e;return(0,o.kt)(T,(0,r.Z)({},O,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"useanimatedscrollhandler"},"useAnimatedScrollHandler"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"useAnimatedScrollHandler")," is a hook that returns an event handler reference. It can be used with React Native's scrollable components."),(0,o.kt)("h2",{id:"reference"},"Reference"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import { useAnimatedScrollHandler } from 'react-native-reanimated';\n\nfunction App() {\n  const offsetY = useSharedValue(0);\n\n  // highlight-start\n  const scrollHandler = useAnimatedScrollHandler((event) => {\n    offsetY.value = event.contentOffset.y;\n  });\n  // highlight-end\n\n  // ...\n\n  return <Animated.ScrollView onScroll={scrollHandler} />;\n}\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,"Type definitions"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"function useAnimatedScrollHandler<Context extends Record<string, unknown>>(\n  handlers: ScrollHandler<Context> | ScrollHandlers<Context>,\n  dependencies?: DependencyList\n): ScrollHandlerProcessed<Context>;\n\ntype ScrollHandler<\n  Context extends Record<string, unknown> = Record<string, unknown>\n> = (event: ReanimatedScrollEvent, context: Context) => void;\n\ninterface ScrollHandlers<Context extends Record<string, unknown>> {\n  onScroll?: ScrollHandler<Context>;\n  onBeginDrag?: ScrollHandler<Context>;\n  onEndDrag?: ScrollHandler<Context>;\n  onMomentumBegin?: ScrollHandler<Context>;\n  onMomentumEnd?: ScrollHandler<Context>;\n}\n\ntype DependencyList = Array<unknown> | undefined;\n"))),(0,o.kt)("h3",{id:"arguments"},"Arguments"),(0,o.kt)("h4",{id:"handlers"},(0,o.kt)("inlineCode",{parentName:"h4"},"handlers")),(0,o.kt)("p",null,"Object containing custom keys matching native event names. Following keys are available:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"onScroll")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"onBeginDrag")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"onEndDrag")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"onMomentumBegin")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"onMomentumEnd"))),(0,o.kt)("p",null,"The values in the object should be individual worklets.\nEach of the worklet will be triggered when the corresponding event is dispatched on the connected Scrollable component."),(0,o.kt)("p",null,"Each of the event worklets will receive the following parameters when called:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"event")," - event object carrying the information about the scroll.\nThe payload can differ depending on the type of the event.\nPlease consult ",(0,o.kt)("a",{parentName:"p",href:"https://reactnative.dev/docs/scrollview"},"React Native's ScrollView documentation")," to learn about scroll event structure.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"p"},"context")," - plain JS object that can be used to store some state.\nThis object will persist in between scroll event occurrences and you can read and write any data to it.\nWhen there are several event handlers provided in a form of an object of worklets, the ",(0,o.kt)("inlineCode",{parentName:"p"},"context")," object will be shared in between the worklets allowing them to communicate with each other."))),(0,o.kt)("h4",{id:"dependencies-"},(0,o.kt)("inlineCode",{parentName:"h4"},"dependencies")," ",(0,o.kt)(C,{mdxType:"Optional"})),(0,o.kt)("p",null,"An optional array of dependencies."),(0,o.kt)("p",null,"Only relevant when using Reanimated ",(0,o.kt)("a",{parentName:"p",href:"/docs/guides/web-support/#web-without-the-babel-plugin"},"without the Babel plugin on the Web.")),(0,o.kt)("h3",{id:"returns"},"Returns"),(0,o.kt)("p",null,"The hook returns a handler object that can be hooked into a scrollable container. The returned handler should be passed under ",(0,o.kt)("inlineCode",{parentName:"p"},"onScroll")," parameter regardless of whether it is configured to receive only scroll or also momentum or drag events. In order for the returned handler to be properly triggered, you should use containers that are wrapped with ",(0,o.kt)("inlineCode",{parentName:"p"},"Animated")," (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"Animated.ScrollView")," and not just ",(0,o.kt)("inlineCode",{parentName:"p"},"ScrollView"),")."),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)(H,{src:y,component:v,mdxType:"InteractiveExample"}),(0,o.kt)("h2",{id:"remarks"},"Remarks"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The returned handler may be passed to multiple components. In such situation, the handler will invoke for the given events each time any of the components dispatches them."),(0,o.kt)("li",{parentName:"ul"},"If a single worklet function of type ",(0,o.kt)("inlineCode",{parentName:"li"},"(event) => void")," is passed instead of a map of functions matched to event keys, it's treated as a handler for the ",(0,o.kt)("inlineCode",{parentName:"li"},"onScroll")," event."),(0,o.kt)("li",{parentName:"ul"},"Only ",(0,o.kt)("inlineCode",{parentName:"li"},"onScroll")," event works on Web.")),(0,o.kt)("h2",{id:"platform-compatibility"},"Platform compatibility"),(0,o.kt)("div",{className:"platform-compatibility"},(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Android"),(0,o.kt)("th",{parentName:"tr",align:null},"iOS"),(0,o.kt)("th",{parentName:"tr",align:null},"Web"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,o.kt)("td",{parentName:"tr",align:null},"\u2705"),(0,o.kt)("td",{parentName:"tr",align:null},"\u2705"))))))}_.isMDXComponent=!0},76636:(e,n,t)=>{t.d(n,{Z:()=>m});var r=t(87462),a=t(63366),o=t(67294),l=t(28033),i=t(67177),c=t(13145),s=["style"],d=c.Z&&window.CSS&&window.CSS.supports&&window.CSS.supports("top: constant(safe-area-inset-top)")?"constant":"env",u=o.forwardRef(((e,n)=>{var t=e.style,c=(0,a.Z)(e,s);return o.createElement(i.Z,(0,r.Z)({},c,{ref:n,style:l.Z.compose(p.root,t)}))}));u.displayName="SafeAreaView";var p=l.Z.create({root:{paddingTop:d+"(safe-area-inset-top)",paddingRight:d+"(safe-area-inset-right)",paddingBottom:d+"(safe-area-inset-bottom)",paddingLeft:d+"(safe-area-inset-left)"}});const m=u}}]);